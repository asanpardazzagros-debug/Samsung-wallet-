๐ ุณุณุชู ุงุญุฑุงุฒ ููุช ู ุฑูุฒูฺฏุงุฑ ูพุดุฑูุชู

๐๏ธ ุณุงุฎุชุงุฑ ุงููุช

backend/middleware/auth.js

```javascript
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
const crypto = require('crypto');

const JWT_SECRET = process.env.JWT_SECRET || 'your-super-secret-key';
const SALT_ROUNDS = 12;

// ุชููุฏ ูุด ุฑูุฒ ุนุจูุฑ
const hashPassword = async (password) => {
    return await bcrypt.hash(password, SALT_ROUNDS);
};

// ุจุฑุฑุณ ุฑูุฒ ุนุจูุฑ
const verifyPassword = async (password, hashedPassword) => {
    return await bcrypt.compare(password, hashedPassword);
};

// ุชููุฏ ุชูฺฉู JWT
const generateToken = (userId, username) => {
    return jwt.sign(
        { 
            userId, 
            username,
            iss: 'samsung-vault',
            aud: 'samsung-vault-web'
        },
        JWT_SECRET,
        { expiresIn: '24h' }
    );
};

// ุงุนุชุจุงุฑุณูุฌ ุชูฺฉู
const verifyToken = (token) => {
    try {
        return jwt.verify(token, JWT_SECRET);
    } catch (error) {
        throw new Error('ุชูฺฉู ูุงูุนุชุจุฑ ุงุณุช');
    }
};

// ูุฏููุฑ ุจุฑุง ุจุฑุฑุณ ุงุญุฑุงุฒ ููุช
const authenticateToken = (req, res, next) => {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1];

    if (!token) {
        return res.status(401).json({ error: 'ุฏุณุชุฑุณ ุบุฑูุฌุงุฒ' });
    }

    try {
        const decoded = verifyToken(token);
        req.user = decoded;
        next();
    } catch (error) {
        return res.status(403).json({ error: 'ุชูฺฉู ูุงูุนุชุจุฑ' });
    }
};

module.exports = {
    hashPassword,
    verifyPassword,
    generateToken,
    verifyToken,
    authenticateToken
};
```

backend/middleware/encryption.js

```javascript
const crypto = require('crypto');
const bcrypt = require('bcryptjs');

class EncryptionService {
    constructor() {
        this.algorithm = 'aes-256-gcm';
        this.keyLength = 32;
        this.ivLength = 16;
        this.authTagLength = 16;
    }

    // ุชููุฏ ฺฉูุฏ ุงุตู ุงุฒ ุฑูุฒ ุนุจูุฑ ฺฉุงุฑุจุฑ
    async deriveMasterKey(password, salt) {
        return new Promise((resolve, reject) => {
            crypto.scrypt(password, salt, this.keyLength, (err, derivedKey) => {
                if (err) reject(err);
                resolve(derivedKey);
            });
        });
    }

    // ุชููุฏ ููฺฉ ุชุตุงุฏู
    generateSalt() {
        return crypto.randomBytes(16);
    }

    // ุชููุฏ IV ุชุตุงุฏู
    generateIV() {
        return crypto.randomBytes(this.ivLength);
    }

    // ุฑูุฒูฺฏุงุฑ ุฏุงุฏู
    encryptData(data, masterKey) {
        try {
            const iv = this.generateIV();
            const cipher = crypto.createCipher(this.algorithm, masterKey);
            cipher.setAAD(Buffer.from('samsung-vault'));
            
            let encrypted = cipher.update(data, 'utf8', 'hex');
            encrypted += cipher.final('hex');
            
            const authTag = cipher.getAuthTag();
            
            return {
                encryptedData: encrypted,
                iv: iv.toString('hex'),
                authTag: authTag.toString('hex')
            };
        } catch (error) {
            throw new Error('ุฎุทุง ุฏุฑ ุฑูุฒูฺฏุงุฑ ุฏุงุฏู');
        }
    }

    // ุฑูุฒฺฏุดุง ุฏุงุฏู
    decryptData(encryptedData, iv, authTag, masterKey) {
        try {
            const decipher = crypto.createDecipher(this.algorithm, masterKey);
            decipher.setAAD(Buffer.from('samsung-vault'));
            decipher.setAuthTag(Buffer.from(authTag, 'hex'));
            
            let decrypted = decipher.update(encryptedData, 'hex', 'utf8');
            decrypted += decipher.final('utf8');
            
            return decrypted;
        } catch (error) {
            throw new Error('ุฎุทุง ุฏุฑ ุฑูุฒฺฏุดุง ุฏุงุฏู');
        }
    }

    // ุฑูุฒูฺฏุงุฑ ูุงู
    encryptFile(buffer, masterKey) {
        const iv = this.generateIV();
        const cipher = crypto.createCipher(this.algorithm, masterKey);
        
        const encrypted = Buffer.concat([
            cipher.update(buffer),
            cipher.final()
        ]);
        
        const authTag = cipher.getAuthTag();
        
        return {
            encryptedData: encrypted,
            iv: iv,
            authTag: authTag
        };
    }

    // ุชููุฏ ฺฉูุฏ ุชุตุงุฏู ุจุฑุง ูุฑ ุขุชู
    generateItemKey() {
        return crypto.randomBytes(32);
    }
}

module.exports = new EncryptionService();
```

backend/routes/auth.js

```javascript
const express = require('express');
const router = express.Router();
const { 
    hashPassword, 
    verifyPassword, 
    generateToken,
    authenticateToken 
} = require('../middleware/auth');
const User = require('../models/User');

// ุซุจุช ูุงู ฺฉุงุฑุจุฑ
router.post('/register', async (req, res) => {
    try {
        const { username, password, email } = req.body;

        // ุจุฑุฑุณ ูุฌูุฏ ฺฉุงุฑุจุฑ
        const existingUser = await User.findOne({ 
            $or: [{ username }, { email }] 
        });
        
        if (existingUser) {
            return res.status(400).json({ 
                error: 'ูุงู ฺฉุงุฑุจุฑ ุง ุงูู ูุจูุงู ุงุณุชูุงุฏู ุดุฏู ุงุณุช' 
            });
        }

        // ูุด ฺฉุฑุฏู ุฑูุฒ ุนุจูุฑ
        const hashedPassword = await hashPassword(password);

        // ุงุฌุงุฏ ฺฉุงุฑุจุฑ ุฌุฏุฏ
        const newUser = new User({
            username,
            email,
            password: hashedPassword,
            createdAt: new Date()
        });

        await newUser.save();

        // ุชููุฏ ุชูฺฉู
        const token = generateToken(newUser._id, username);

        res.status(201).json({
            message: 'ุญุณุงุจ ฺฉุงุฑุจุฑ ุจุง ููููุช ุงุฌุงุฏ ุดุฏ',
            token,
            user: {
                id: newUser._id,
                username: newUser.username,
                email: newUser.email
            }
        });

    } catch (error) {
        res.status(500).json({ 
            error: 'ุฎุทุง ุฏุฑ ุงุฌุงุฏ ุญุณุงุจ ฺฉุงุฑุจุฑ' 
        });
    }
});

// ูุฑูุฏ ฺฉุงุฑุจุฑ
router.post('/login', async (req, res) => {
    try {
        const { username, password } = req.body;

        // ูพุฏุง ฺฉุฑุฏู ฺฉุงุฑุจุฑ
        const user = await User.findOne({ username });
        if (!user) {
            return res.status(401).json({ 
                error: 'ูุงู ฺฉุงุฑุจุฑ ุง ุฑูุฒ ุนุจูุฑ ุงุดุชุจุงู ุงุณุช' 
            });
        }

        // ุจุฑุฑุณ ุฑูุฒ ุนุจูุฑ
        const isValidPassword = await verifyPassword(password, user.password);
        if (!isValidPassword) {
            return res.status(401).json({ 
                error: 'ูุงู ฺฉุงุฑุจุฑ ุง ุฑูุฒ ุนุจูุฑ ุงุดุชุจุงู ุงุณุช' 
            });
        }

        // ุขูพุฏุช ุขุฎุฑู ูุฑูุฏ
        user.lastLogin = new Date();
        await user.save();

        // ุชููุฏ ุชูฺฉู
        const token = generateToken(user._id, username);

        res.json({
            message: 'ูุฑูุฏ ููููุชโุขูุฒ',
            token,
            user: {
                id: user._id,
                username: user.username,
                email: user.email
            }
        });

    } catch (error) {
        res.status(500).json({ 
            error: 'ุฎุทุง ุฏุฑ ูุฑูุฏ ุจู ุณุณุชู' 
        });
    }
});

// ุจุฑุฑุณ ูุถุนุช ุชูฺฉู
router.get('/verify', authenticateToken, (req, res) => {
    res.json({ 
        valid: true, 
        user: req.user 
    });
});

// ุชุบุฑ ุฑูุฒ ุนุจูุฑ
router.post('/change-password', authenticateToken, async (req, res) => {
    try {
        const { currentPassword, newPassword } = req.body;
        const userId = req.user.userId;

        const user = await User.findById(userId);
        if (!user) {
            return res.status(404).json({ error: 'ฺฉุงุฑุจุฑ ุงูุช ูุดุฏ' });
        }

        // ุจุฑุฑุณ ุฑูุฒ ุนุจูุฑ ูุนู
        const isValid = await verifyPassword(currentPassword, user.password);
        if (!isValid) {
            return res.status(401).json({ error: 'ุฑูุฒ ุนุจูุฑ ูุนู ุงุดุชุจุงู ุงุณุช' });
        }

        // ูุด ฺฉุฑุฏู ุฑูุฒ ุนุจูุฑ ุฌุฏุฏ
        user.password = await hashPassword(newPassword);
        await user.save();

        res.json({ message: 'ุฑูุฒ ุนุจูุฑ ุจุง ููููุช ุชุบุฑ ุงูุช' });

    } catch (error) {
        res.status(500).json({ error: 'ุฎุทุง ุฏุฑ ุชุบุฑ ุฑูุฒ ุนุจูุฑ' });
    }
});

module.exports = router;
```

frontend/js/auth.js

```javascript
class AuthManager {
    constructor() {
        this.token = localStorage.getItem('samsung_vault_token');
        this.user = JSON.parse(localStorage.getItem('samsung_vault_user') || 'null');
        this.baseURL = 'http://localhost:3000/api';
    }

    // ุชูุธู ูุฏุฑูุง ุฏุฑุฎูุงุณุช
    getHeaders() {
        return {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${this.token}`
        };
    }

    // ุจุฑุฑุณ ูุถุนุช ูุงฺฏู
    isLoggedIn() {
        return !!this.token && !!this.user;
    }

    // ูุงฺฏู
    async login(username, password) {
        try {
            const response = await fetch(`${this.baseURL}/auth/login`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ username, password })
            });

            const data = await response.json();

            if (!response.ok) {
                throw new Error(data.error || 'ุฎุทุง ุฏุฑ ูุฑูุฏ');
            }

            this.token = data.token;
            this.user = data.user;

            // ุฐุฎุฑู ุฏุฑ localStorage
            localStorage.setItem('samsung_vault_token', this.token);
            localStorage.setItem('samsung_vault_user', JSON.stringify(this.user));

            return data;

        } catch (error) {
            throw error;
        }
    }

    // ุซุจุช ูุงู
    async register(username, password, email) {
        try {
            const response = await fetch(`${this.baseURL}/auth/register`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ username, password, email })
            });

            const data = await response.json();

            if (!response.ok) {
                throw new Error(data.error || 'ุฎุทุง ุฏุฑ ุซุจุช ูุงู');
            }

            this.token = data.token;
            this.user = data.user;

            // ุฐุฎุฑู ุฏุฑ localStorage
            localStorage.setItem('samsung_vault_token', this.token);
            localStorage.setItem('samsung_vault_user', JSON.stringify(this.user));

            return data;

        } catch (error) {
            throw error;
        }
    }

    // ูุงฺฏ ุงูุช
    logout() {
        this.token = null;
        this.user = null;
        localStorage.removeItem('samsung_vault_token');
        localStorage.removeItem('samsung_vault_user');
        window.location.href = '/';
    }

    // ุจุฑุฑุณ ุงุนุชุจุงุฑ ุชูฺฉู
    async verifyToken() {
        if (!this.token) return false;

        try {
            const response = await fetch(`${this.baseURL}/auth/verify`, {
                headers: this.getHeaders()
            });

            return response.ok;
        } catch (error) {
            return false;
        }
    }

    // ุชุบุฑ ุฑูุฒ ุนุจูุฑ
    async changePassword(currentPassword, newPassword) {
        try {
            const response = await fetch(`${this.baseURL}/auth/change-password`, {
                method: 'POST',
                headers: this.getHeaders(),
                body: JSON.stringify({ currentPassword, newPassword })
            });

            const data = await response.json();

            if (!response.ok) {
                throw new Error(data.error || 'ุฎุทุง ุฏุฑ ุชุบุฑ ุฑูุฒ ุนุจูุฑ');
            }

            return data;

        } catch (error) {
            throw error;
        }
    }
}

// ุงุฌุงุฏ ููููู ุงุฒ AuthManager
const authManager = new AuthManager();
```

frontend/js/crypto.js

```javascript
class ClientCrypto {
    constructor() {
        this.masterKey = null;
    }

    // ุชููุฏ ฺฉูุฏ ุงุตู ุงุฒ ุฑูุฒ ุนุจูุฑ
    async deriveMasterKey(password, salt) {
        const encoder = new TextEncoder();
        const keyMaterial = await crypto.subtle.importKey(
            'raw',
            encoder.encode(password),
            'PBKDF2',
            false,
            ['deriveBits', 'deriveKey']
        );

        const key = await crypto.subtle.deriveKey(
            {
                name: 'PBKDF2',
                salt: encoder.encode(salt),
                iterations: 100000,
                hash: 'SHA-256'
            },
            keyMaterial,
            { name: 'AES-GCM', length: 256 },
            false,
            ['encrypt', 'decrypt']
        );

        this.masterKey = key;
        return key;
    }

    // ุฑูุฒูฺฏุงุฑ ุฏุงุฏู ุฏุฑ ุณูุช ฺฉูุงูุช
    async encryptData(data) {
        if (!this.masterKey) {
            throw new Error('ฺฉูุฏ ุงุตู ุชูุธู ูุดุฏู ุงุณุช');
        }

        const encoder = new TextEncoder();
        const iv = crypto.getRandomValues(new Uint8Array(12));
        
        const encryptedData = await crypto.subtle.encrypt(
            {
                name: 'AES-GCM',
                iv: iv,
                additionalData: encoder.encode('samsung-vault')
            },
            this.masterKey,
            encoder.encode(data)
        );

        return {
            encryptedData: Array.from(new Uint8Array(encryptedData)),
            iv: Array.from(iv)
        };
    }

    // ุฑูุฒฺฏุดุง ุฏุงุฏู ุฏุฑ ุณูุช ฺฉูุงูุช
    async decryptData(encryptedData, iv) {
        if (!this.masterKey) {
            throw new Error('ฺฉูุฏ ุงุตู ุชูุธู ูุดุฏู ุงุณุช');
        }

        const decoder = new TextDecoder();
        const encoder = new TextEncoder();

        try {
            const decryptedData = await crypto.subtle.decrypt(
                {
                    name: 'AES-GCM',
                    iv: new Uint8Array(iv),
                    additionalData: encoder.encode('samsung-vault')
                },
                this.masterKey,
                new Uint8Array(encryptedData)
            );

            return decoder.decode(decryptedData);
        } catch (error) {
            throw new Error('ุฎุทุง ุฏุฑ ุฑูุฒฺฏุดุง ุฏุงุฏู');
        }
    }

    // ุชููุฏ ูุด ุจุฑุง ุฏุงุฏู
    async generateHash(data) {
        const encoder = new TextEncoder();
        const dataBuffer = encoder.encode(data);
        
        const hashBuffer = await crypto.subtle.digest('SHA-256', dataBuffer);
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        
        return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    }

    // ุชููุฏ ฺฉูุฏ ุชุตุงุฏู
    generateRandomKey(length = 32) {
        return crypto.getRandomValues(new Uint8Array(length));
    }
}

// ุงุฌุงุฏ ููููู ุงุฒ ClientCrypto
const clientCrypto = new ClientCrypto();
```

.env (ูุงู ูุญุท)

```env
# ุชูุธูุงุช ุณุฑูุฑ
PORT=3000
NODE_ENV=production

# ุงููุช
JWT_SECRET=your-super-secure-jwt-secret-key-here
BCRYPT_SALT_ROUNDS=12

# ุฏุชุงุจุณ
MONGODB_URI=mongodb://localhost:27017/samsung-vault

# ุฑูุฒูฺฏุงุฑ
ENCRYPTION_ALGORITHM=aes-256-gcm
KEY_LENGTH=32
IV_LENGTH=16

# CORS
ALLOWED_ORIGINS=https://yourdomain.com,http://localhost:3000
```

ุงู ุณุณุชู ุงููุช ุดุงูู:

ยท ๐ ุงุญุฑุงุฒ ููุช ูพุดุฑูุชู ุจุง JWT ู bcrypt
ยท ๐ ุฑูุฒูฺฏุงุฑ end-to-end ุจุง AES-256-GCM
ยท ๐ก๏ธ ูุฏููุฑูุง ุงููุช ุจุฑุง ูุญุงูุธุช ุงุฒ API
ยท ๐ฑ ุฑูุฒูฺฏุงุฑ ุณูุช ฺฉูุงูุช ุจุฑุง ุญุฏุงฺฉุซุฑ ุงููุช
ยท ๐ ูุฏุฑุช ฺฉูุฏูุง ุงูู ุจุฑุง ูุฑ ฺฉุงุฑุจุฑ

